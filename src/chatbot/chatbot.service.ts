import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { HistoryService } from 'src/history/history.service';
import { ResponseService } from 'src/response/response.service';
import { UserService } from 'src/user/user.service';
import { WhatsAppService } from 'src/whatsapp/whatsapp.service';
import { ChatbotResponse } from './chatbot.entity';
import { User } from 'src/user/user.entity';
import { UnsplashService } from 'src/unsplash/unsplash.service';
import { YoutubeService } from 'src/youtube/youtube.service';
import { GamificationService } from 'src/gamification/gamification.service';
import { GptService } from 'src/gpt/gpt.service';

@Injectable()
export class ChatbotService implements OnModuleInit {
  private readonly logger = new Logger(ChatbotService.name);
  private readonly stressKeywords = [
    'estr√©s',
    'estres',
    'ansiedad',
    'ansioso',
    'nervios',
    'relajarme',
    'calmarme',
    'abrumado',
    'tensi√≥n',
    'preocupado',
    'agobiado',
    'estresada',
    'angustia',
    'quemado',
    'burnout',
    'p√°nico',
    'no puedo m√°s',
    'colapsado',
  ];

  private readonly crisisKeywords = [
    'suicidio',
    'morir',
    'ayuda urgente',
    'no puedo respirar',
    'quiero desaparecer',
    'no valgo nada',
  ];

  constructor(
    private readonly historyService: HistoryService,
    private readonly responseService: ResponseService,
    private readonly userService: UserService,
    private readonly whatsappService: WhatsAppService,
    private readonly unsplashService: UnsplashService,
    private readonly youtubeService: YoutubeService,
    private readonly gamificationService: GamificationService,
    private readonly gptService: GptService,
  ) {}

  async onModuleInit() {
    setInterval(async () => {
      await this.sendFollowUpMessages();
    }, 60000);
  }

  // --- M√©todos principales ---
  async processMessage(
    message: string,
    phoneNumber: string,
  ): Promise<ChatbotResponse> {
    let responseSent = false;
    let finalResponse: ChatbotResponse | null = null;

    try {
      const normalizedMessage = this.normalizeMessage(message);
      const user = await this.userService.findByPhoneNumber(phoneNumber);

      // 1. Manejo de crisis (prioridad m√°xima)
      if (this.isCrisisMessage(normalizedMessage)) {
        finalResponse = this.buildResponse(
          this.getCrisisResponse(),
          user?.userName,
        );
        responseSent = true;
      }

      // 2. Manejo de feedback
      if (
        !responseSent &&
        (normalizedMessage === 'üëç' || normalizedMessage === 'üëé')
      ) {
        finalResponse = await this.handleFeedback(user, normalizedMessage);
        responseSent = true;
      }

      // 3. Manejo de cancelaci√≥n
      if (!responseSent && normalizedMessage === 'cancelar') {
        finalResponse = await this.handleCancelation(user);
        responseSent = true;
      }

      // 4. Flujo para nuevos usuarios
      if (!responseSent && !user) {
        finalResponse = await this.handleNewUser(phoneNumber);
        responseSent = true;
      }

      if (user) {
        // Actualizar interacci√≥n y gamificaci√≥n
        await this.updateInteractionStreak(user);
        await this.gamificationService.addPoints(user, 1);

        // 5. Buscar respuesta local primero
        if (!responseSent) {
          const localResponse = await this.getLocalResponse(
            user,
            normalizedMessage,
            message,
          );
          if (localResponse) {
            finalResponse = localResponse;
            responseSent = true;
          }
        }

        // 6. Manejo de estados espec√≠ficos
        if (!responseSent) {
          finalResponse = await this.handleUserStates(
            user,
            normalizedMessage,
            message,
          );
          responseSent = finalResponse !== null;
        }

        // 7. Manejo de escala emocional
        if (!responseSent) {
          const escala = this.parseEscala(message);
          if (escala !== undefined) {
            finalResponse = await this.handleEmotionalScale(
              user,
              escala,
              phoneNumber,
            );
            responseSent = true;
          }
        }
      }

      // 8. Finalmente, usar GPT si no hay respuesta local
      if (!responseSent && user) {
        finalResponse = await this.getAIResponse(user, message);
        responseSent = true;
      }

      return finalResponse || this.getErrorResponse();
    } catch (error) {
      this.logger.error(
        `Error en processMessage: ${error.message}`,
        error.stack,
      );
      return this.getErrorResponse();
    }
  }

  // --- M√©todos de ayuda ---
  private normalizeMessage(message: string): string {
    return message
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .toLowerCase()
      .trim();
  }

  private isCrisisMessage(message: string): boolean {
    return this.crisisKeywords.some((keyword) =>
      this.normalizeMessage(message).includes(keyword),
    );
  }

  private getCrisisResponse(): string {
    return (
      `‚ö†Ô∏è **¬°Veo que est√°s en una situaci√≥n dif√≠cil!** ‚ö†Ô∏è\n\n` +
      `1. Llama a tu l√≠nea local de ayuda: *0994101922* üì±\n` +
      `2. Ejercicio de grounding: Nombra:\n   - 5 cosas que ves üëÄ\n   - 4 que puedes tocar ‚úã\n   - 3 que oyes üëÇ\n` +
      `3. Respira conmigo: Inhala 4s... Mant√©n 7s... Exhala 8s... üßò`
    );
  }

  private buildResponse(
    message: string,
    userName?: string,
    emotionalScale?: number,
  ): ChatbotResponse {
    return {
      response: message,
      emotionalScale,
      userName,
      metadata: { timestamp: new Date().toISOString() },
    };
  }

  // --- Manejo de usuarios ---
  private async handleNewUser(phoneNumber: string): Promise<ChatbotResponse> {
    await this.userService.createUser({
      phoneNumber,
      userName: '',
      wantsSupport: true,
      interactionStreak: 0,
      positiveEmotionStreak: 0,
      isSettingFollowUpTime: false,
      isChoosingResource: false,
      isChoosingStressOption: false,
      recentlyOfferedHelp: false,
      lastInteraction: new Date(),
      points: 0,
      unlockedAchievements: [],
    });

    return {
      response: '¬°Hola! ‚ú® Soy Lumi, tu chatbot de apoyo. ¬øC√≥mo te llamas?',
      emotionalScale: undefined,
      userName: undefined,
    };
  }

  private async updateInteractionStreak(user: User): Promise<void> {
    const today = new Date();
    const lastInteractionDate = user.lastInteraction;

    if (lastInteractionDate) {
      const diffInDays = Math.floor(
        (today.getTime() - lastInteractionDate.getTime()) /
          (1000 * 60 * 60 * 24),
      );

      if (diffInDays === 1) {
        user.interactionStreak += 1;
        await this.gamificationService.addPoints(user, 5);
      } else if (diffInDays > 1) {
        user.interactionStreak = 1;
      }
    } else {
      user.interactionStreak = 1;
    }

    user.lastInteraction = today;
    await this.userService.updateUser(user);
  }

  // --- Respuestas locales ---
  private async getLocalResponse(
    user: User,
    normalizedMessage: string,
    originalMessage: string,
  ): Promise<ChatbotResponse | null> {
    // 1. Comandos especiales
    if (normalizedMessage.startsWith('/')) {
      return this.handleCommands(user, normalizedMessage);
    }

    // 2. Buscar en respuestas locales configuradas
    const context = this.getCurrentContext(user);
    const localResponse = await this.responseService.getBestResponse(
      context,
      originalMessage,
    );

    if (localResponse) {
      return this.buildResponse(localResponse, user.userName);
    }

    return null;
  }

  private getCurrentContext(user: User): string {
    if (user.isSettingFollowUpTime) return 'followup';
    if (user.isChoosingResource) return 'resource';
    if (user.isChoosingStressOption) return 'stress';
    if (!user.userName) return 'name_registration';
    return 'general';
  }

  private async handleUserStates(
    user: User,
    normalizedMessage: string,
    message: string,
  ): Promise<ChatbotResponse | null> {
    // 1. Manejo de estados espec√≠ficos
    if (user.isSettingFollowUpTime) {
      return this.handleFollowUpTimeSetting(user, message);
    }
    if (user.isChoosingResource) {
      if (['foto', 'video', 'm√∫sica'].includes(normalizedMessage)) {
        return this.handleResourceRequest(
          user,
          normalizedMessage as 'foto' | 'video' | 'm√∫sica',
        );
      } else {
        return this.buildResponse(
          'Por favor elige una opci√≥n v√°lida: "foto", "video" o "m√∫sica"',
          user.userName,
        );
      }
    }
    if (user.isChoosingStressOption) {
      return this.handleStressOptionSelection(user, message);
    }

    // 2. Flujos especiales
    if (normalizedMessage.includes('hola')) {
      return this.handleGreeting(user);
    }
    if (!user.userName) {
      return this.handleUserNameRegistration(user, message);
    }

    // 3. Detecci√≥n de estr√©s
    if (
      !user.recentlyOfferedHelp &&
      this.isStressRelatedMessage(normalizedMessage)
    ) {
      return this.handleStressResponse(user);
    }

    return null;
  }

  private async handleCancelation(user: User): Promise<ChatbotResponse> {
    await this.userService.updateUser({
      ...user,
      isSettingFollowUpTime: false,
      isChoosingResource: false,
      isChoosingStressOption: false,
    });
    return this.buildResponse(
      'Operaci√≥n cancelada. ¬øEn qu√© m√°s puedo ayudarte?',
      user.userName,
    );
  }

  private async handleCommands(
    user: User,
    command: string,
  ): Promise<ChatbotResponse> {
    switch (command) {
      case '/estadisticas':
        const insights = await this.getWeeklyInsights(user);
        return this.buildResponse(
          `üìä *Tus estad√≠sticas:*${insights}`,
          user.userName,
        );

      case '/ayuda':
        return this.buildResponse(
          `üõü *Comandos disponibles:*\n\n` +
            `*/estadisticas* - Ver tus insights semanales üìà\n` +
            `*/recursos* - Mostrar opciones de relajaci√≥n ü§î\n` +
            `*/recordatorio* - Configurar seguimiento ‚è∞`,
          user.userName,
        );

      case '/recursos':
        return this.handleStressResponse(user);

      case '/recordatorio':
        return this.handleReminderOption(user);

      default:
        return this.buildResponse(
          'Comando no reconocido. Usa /ayuda para ver opciones disponibles.',
          user.userName,
        );
    }
  }

  // --- Flujos de conversaci√≥n ---
  private async handleGreeting(user: User): Promise<ChatbotResponse> {
    const emoji = user.positiveEmotionStreak > 3 ? 'üåü' : '‚ú®';
    let response: string;

    if (!user.userName) {
      response = `¬°Hola! ${emoji} Soy Lumi, tu chatbot de apoyo. ¬øC√≥mo te llamas?`;
    } else if (user.interactionStreak > 3) {
      response =
        `¬°Hola de nuevo, ${user.userName}! ${emoji} ¬øEn una escala del 1 al 10, c√≥mo te sientes hoy?\n\n` +
        `Puedes usar:\n` +
        `- /recursos para opciones de relajaci√≥n ü§î\n` +
        `- /recordatorio para programar seguimientos ‚è∞\n` +
        `- /ayuda para ver todos los comandos ‚õëÔ∏è`;
    } else {
      response =
        `¬°Hola, ${user.userName}! ${emoji} ¬øEn una escala del 1 al 10, c√≥mo te sientes hoy?\n\n` +
        `Tambi√©n puedes usar comandos como /recursos o /ayuda ü•∫`;
    }

    return this.buildResponse(response, user.userName);
  }

  private async handleUserNameRegistration(
    user: User,
    message: string,
  ): Promise<ChatbotResponse> {
    await this.userService.updateUser({
      ...user,
      userName: message,
    });

    return this.buildResponse(
      `¬°Hola, ${message}! üòä ¬øEn una escala del 1 al 10, c√≥mo te sientes hoy?`,
      message,
    );
  }

  private parseEscala(message: string): number | undefined {
    const match = message.match(/\b([1-9]|10)\b/);
    return match ? parseInt(match[0], 10) : undefined;
  }

  // --- Integraci√≥n con GPT ---
  private async getAIResponse(
    user: User,
    message: string,
  ): Promise<ChatbotResponse> {
    try {
      const context = this.buildEnhancedContext(user);
      const response = await this.gptService.generateResponse(message, context);
      await this.gamificationService.addPoints(user, 3); // Puntos por usar GPT

      // Verificar logros desbloqueados
      const newAchievements =
        await this.gamificationService.checkAchievements(user);
      if (newAchievements.length > 0) {
        return this.buildResponse(
          `${response}\n\nüéâ ¬°Logro desbloqueado!: ${newAchievements.join(', ')}`,
          user.userName,
        );
      }

      return this.buildResponse(response, user.userName);
    } catch (error) {
      this.logger.error('Error con GPT:', error);
      return this.getFallbackResponse(user);
    }
  }

  private buildEnhancedContext(user: User): string {
    const baseContext = `
      ## Rol:
      Eres Lumi, un chatbot de apoyo emocional con las siguientes caracter√≠sticas:
      - Emp√°tico pero profesional
      - Usa emojis moderadamente (2-3 por respuesta)
      - Responde en espa√±ol coloquial pero correcto
      - S√© conciso (m√°ximo 2 p√°rrafos)
  
      ## Contexto del usuario:
      ${this.buildContext(user)}
  
      ## Directivas:
      1. Para saludos: Pregunta por su estado emocional (1-10)
      2. Si detectas estr√©s: Ofrece t√©cnicas de respiraci√≥n o recursos
      3. En crisis: Muestra n√∫meros de emergencia (0994101922)
      4. Usa el nombre del usuario (${user.userName || 'amigo/a'})
      5. Para comandos (/ayuda, /recursos): Responde brevemente
    `;

    // A√±ade contexto adicional seg√∫n el estado del usuario
    if (user.isChoosingResource) {
      return (
        baseContext +
        '\n- El usuario est√° eligiendo un recurso (foto/video/m√∫sica)'
      );
    }
    if (user.emotionalScale && user.emotionalScale < 5) {
      return baseContext + '\n- El usuario report√≥ estado emocional bajo';
    }

    return baseContext;
  }

  private buildContext(user: User): string {
    return `
      Nombre: ${user.userName || 'No proporcionado'}
      Estado emocional: ${user.emotionalScale || 'No reportado'}/10
      Puntos: ${user.points || 0}
      Logros: ${user.unlockedAchievements?.join(', ') || 'Ninguno'}
      Interacciones consecutivas: ${user.interactionStreak}
      Recursos usados: ${user.resourcesUsed?.map((r) => r.type).join(', ') || 'Ninguno'}
      √öltimo feedback: ${user.lastFeedback || 'Ninguno'}
    `;
  }

  private getFallbackResponse(user: User): ChatbotResponse {
    const fallbacks = [
      `Vaya, tengo dificultades t√©cnicas. ¬øPodr√≠as repetirlo, ${user.userName || ''}?`,
      'Estoy teniendo problemas para entender. ¬øPodr√≠as reformularlo?',
      '¬°Ups! Algo no funcion√≥. ¬øQuieres intentarlo de nuevo?',
    ];

    return this.buildResponse(
      fallbacks[Math.floor(Math.random() * fallbacks.length)],
      user.userName,
    );
  }

  private async handleEmotionalScale(
    user: User,
    escala: number,
    phoneNumber: string,
  ): Promise<ChatbotResponse> {
    await this.historyService.saveEmotionalScale(phoneNumber, escala);
    await this.updatePositiveEmotionStreak(user, escala);
    await this.userService.updateUser({
      ...user,
      emotionalScale: escala,
    });

    const responseMessage = this.getEscalaResponse(escala, user);

    if (escala < 5) {
      return this.offerStressSupport(user, responseMessage);
    }

    return this.buildResponse(responseMessage, user.userName, escala);
  }

  private getEscalaResponse(escala: number, user: User): string {
    const emoji = this.getEmojiByScale(escala);
    const streakMsg =
      user.positiveEmotionStreak > 3
        ? ` ¬°Llevas ${user.positiveEmotionStreak} d√≠as sinti√©ndote bien! üåü`
        : '';

    if (escala >= 7) {
      return (
        `¬°Me alegra que te sientas bien! ${emoji}${streakMsg} ¬øEn qu√© m√°s puedo ayudarte?\n\n` +
        `Recuerda que puedes usar /recursos cuando lo necesites üòä`
      );
    } else if (escala >= 5) {
      return (
        `Entiendo que no te sientas del todo bien ${emoji}. ¬øQuieres hablar sobre ello?\n\n` +
        `Tambi√©n puedes probar con /recursos para encontrar ayuda ü•∫`
      );
    } else {
      return (
        `Veo que est√°s pasando un momento dif√≠cil ${emoji}. ¬øTe gustar√≠a que te ayude con alg√∫n recurso para sentirte mejor?\n\n` +
        `Puedes elegir:\n` +
        `1. üåÑ Foto relajante\n` +
        `2. üßò Video de meditaci√≥n\n` +
        `3. üéµ M√∫sica relajante\n` +
        `O usar el comando /recursos ü§î`
      );
    }
  }

  private getEmojiByScale(escala: number): string {
    if (escala >= 7) return 'üòä';
    if (escala >= 5) return 'üòê';
    return 'üòî';
  }

  // --- Manejo de estr√©s y recursos ---
  private isStressRelatedMessage(message: string): boolean {
    return this.stressKeywords.some((keyword) =>
      this.normalizeMessage(message).includes(keyword),
    );
  }

  private async handleStressResponse(user: User): Promise<ChatbotResponse> {
    const weeklyInsights = await this.getWeeklyInsights(user);
    await this.userService.updateUser({
      ...user,
      isChoosingStressOption: true,
      recentlyOfferedHelp: true,
    });

    const options = [
      '1. üåÑ Foto relajante',
      '2. üßò Video de meditaci√≥n',
      '3. üéµ M√∫sica relajante',
      '4. üí¨ Hablar de c√≥mo me siento',
      '5. ‚è∞ Configurar recordatorio',
    ].join('\n');

    return this.buildResponse(
      `${this.getStressResponse(user.userName)}${weeklyInsights}\n\n_Elige una opci√≥n ü•∫:_\n${options}`,
      user.userName,
    );
  }

  private getStressResponse(userName: string): string {
    return `Entiendo que te sientas estresado/a üòì ${userName ? `, ${userName}` : ''}.\n\n`;
  }

  private async offerStressSupport(
    user: User,
    initialMessage: string = '',
  ): Promise<ChatbotResponse> {
    await this.userService.updateUser({
      ...user,
      isChoosingStressOption: true,
    });

    const options = [
      '1. üåÑ Foto relajante',
      '2. üßò Video de meditaci√≥n',
      '3. üéµ M√∫sica relajante',
      '4. üí¨ Hablar de c√≥mo me siento',
      '5. ‚è∞ Configurar recordatorio',
    ].join('\n');

    return this.buildResponse(
      `${initialMessage}\n\nParece que podr√≠as necesitar apoyo ü•∫. Elige una opci√≥n:\n${options}`,
      user.userName,
    );
  }

  private async handleStressOptionSelection(
    user: User,
    message: string,
  ): Promise<ChatbotResponse> {
    const normalizedMessage = this.normalizeMessage(message);
    const optionMap: Record<string, () => Promise<ChatbotResponse>> = {
      '1': () => this.handleResourceRequest(user, 'foto'),
      '2': () => this.handleResourceRequest(user, 'video'),
      '3': () => this.handleResourceRequest(user, 'm√∫sica'),
      '4': () => this.handleTalkOption(user),
      '5': () => this.handleReminderOption(user),
      foto: () => this.handleResourceRequest(user, 'foto'),
      video: () => this.handleResourceRequest(user, 'video'),
      m√∫sica: () => this.handleResourceRequest(user, 'm√∫sica'),
      hablar: () => this.handleTalkOption(user),
      recordatorio: () => this.handleReminderOption(user),
    };

    const handler = optionMap[normalizedMessage];
    if (handler) {
      return handler();
    }

    await this.userService.updateUser({
      ...user,
      isChoosingStressOption: false,
    });
    return this.buildResponse(
      'No entend√≠ tu elecci√≥n üö´. Por favor elige una opci√≥n del 1 al 5 o escribe "foto", "video", "m√∫sica", "hablar" o "recordatorio".',
      user.userName,
    );
  }

  private async handleResourceRequest(
    user: User,
    type: 'foto' | 'video' | 'm√∫sica',
  ): Promise<ChatbotResponse> {
    await this.userService.updateUser({
      ...user,
      isChoosingStressOption: false,
      isChoosingResource: true,
    });

    const queryMap = {
      foto: 'naturaleza relajante',
      video: 'meditaci√≥n guiada',
      m√∫sica: 'm√∫sica relajante',
    };

    try {
      let resource: { url: string; type: string };

      if (type === 'foto') {
        const images = await this.unsplashService.searchImages(
          queryMap[type],
          1,
        );
        if (!images.length) throw new Error('No images found');
        resource = { url: images[0].url, type: 'image' };
      } else {
        const videos = await this.youtubeService.searchVideos(
          queryMap[type],
          1,
        );
        if (!videos.length) throw new Error('No videos found');
        resource = { url: videos[0].url, type: 'video' };
      }

      await this.userService.updateUser({
        ...user,
        isChoosingResource: false,
      });

      const responseText =
        type === 'foto'
          ? `Aqu√≠ tienes una imagen relajante üñºÔ∏è:\n${resource.url}`
          : `Aqu√≠ tienes un video de ${type} üéµ:\n${resource.url}`;

      return this.buildResponse(
        `${responseText}\n\n¬øTe gust√≥? (Responde üëç/üëé)`,
        user.userName,
      );
    } catch (error) {
      console.error(`Error al obtener recurso ${type}:`, error);
      return this.getResourceNotFoundResponse(user, type);
    }
  }

  private async handleTalkOption(user: User): Promise<ChatbotResponse> {
    await this.userService.updateUser({
      ...user,
      isChoosingStressOption: false,
    });
    return this.buildResponse(
      'Cu√©ntame m√°s sobre c√≥mo te sientes. Estoy aqu√≠ para escucharte üí¨.',
      user.userName,
    );
  }

  private async handleReminderOption(user: User): Promise<ChatbotResponse> {
    await this.userService.updateUser({
      ...user,
      isChoosingStressOption: false,
      isSettingFollowUpTime: true,
      isChoosingResource: false,
    });

    return this.buildResponse(
      `¬øA qu√© hora te gustar√≠a recibir recordatorios diarios? ‚è∞\n\n` +
        `Por favor escribe la hora en formato 24 horas (por ejemplo: 14:30 para las 2:30 PM) üòé\n\n` +
        `Puedes cancelar en cualquier momento escribiendo "cancelar" ‚ùå`,
      user.userName,
    );
  }

  private getResourceNotFoundResponse(
    user: User,
    type: string,
  ): ChatbotResponse {
    const alternatives = {
      foto: ['video', 'm√∫sica'],
      video: ['foto', 'm√∫sica'],
      m√∫sica: ['foto', 'video'],
    };
    return this.buildResponse(
      `No pude encontrar ${type === 'm√∫sica' ? 'm√∫sica' : 'un ' + type} üòì. ¬øQuieres intentar con ${alternatives[type as keyof typeof alternatives].join(' o ')}?`,
      user.userName,
    );
  }

  // --- Seguimiento y recordatorios ---
  private async handleFollowUpTimeSetting(
    user: User,
    message: string,
  ): Promise<ChatbotResponse> {
    // Permitir cancelaci√≥n
    if (this.normalizeMessage(message) === 'cancelar') {
      await this.userService.updateUser({
        ...user,
        isSettingFollowUpTime: false,
      });
      return this.buildResponse(
        'Configuraci√≥n de recordatorio cancelada ‚ùå. ¬øEn qu√© m√°s puedo ayudarte?',
        user.userName,
      );
    }

    const timeRegex = /^([01]?\d|2[0-3]):([0-5]\d)$/; // Acepta 9:30 o 09:30
    if (!timeRegex.test(message)) {
      return this.buildResponse(
        'Formato de hora no v√°lido ü•∫. Por favor ingresa la hora en formato 24h üôÑ (ej. 14:30) o escribe "cancelar"',
        user.userName,
      );
    }

    // Formatear la hora (asegurar dos d√≠gitos)
    const [hours, minutes] = message.split(':');
    const formattedTime = `${hours.padStart(2, '0')}:${minutes}`;

    await this.userService.updateUser({
      ...user,
      followUpTime: formattedTime,
      isSettingFollowUpTime: false,
    });

    return this.buildResponse(
      `‚úÖ Recordatorio configurado para las ${formattedTime}.\n` +
        `Te enviar√© un mensaje a esta hora cada d√≠a para ver c√≥mo est√°s üòä.\n\n` +
        `¬øEn qu√© m√°s puedo ayudarte ü§î?`,
      user.userName,
    );
  }

  async sendFollowUpMessages() {
    const currentTime = new Date().toTimeString().slice(0, 5);
    const users = await this.userService.getUsersForFollowUp(currentTime);

    for (const user of users) {
      try {
        // Verificar si ya se envi√≥ un mensaje recientemente
        if (
          user.lastFollowUp &&
          new Date().getTime() - user.lastFollowUp.getTime() < 60000
        ) {
          continue;
        }

        let message: string;

        if (user.positiveEmotionStreak > 3) {
          message = `¬°${user.userName}, tu racha positiva es impresionante! üåü ¬øSigues bien hoy?`;
        } else if (user.emotionalScale && user.emotionalScale < 5) {
          message = `Hola ${user.userName}, ¬øc√≥mo vas con ese √°nimo? üòä ¬øHa mejorado?`;
        } else {
          message = `Hola ${user.userName}, ¬øc√≥mo te sientes hoy en una escala del 1 al 10? üòä`;
        }

        const messageSent = await this.whatsappService.sendMessage(
          user.phoneNumber,
          message,
        );

        if (messageSent) {
          user.lastFollowUp = new Date();
          await this.gamificationService.addPoints(user, 2); // Puntos por responder seguimiento
          await this.userService.updateUser(user);
          this.logger.log(`Recordatorio enviado a ${user.phoneNumber}`);
        }
      } catch (error) {
        this.logger.error(
          `Error enviando follow-up a ${user.phoneNumber}: ${error.message}`,
        );
      }
    }
  }

  // --- Feedback y an√°lisis ---
  private async handleFeedback(
    user: User,
    feedback: 'üëç' | 'üëé',
  ): Promise<ChatbotResponse> {
    await this.userService.updateUser({
      ...user,
      lastFeedback: feedback,
    });

    return this.buildResponse(
      feedback === 'üëç'
        ? '¬°Me alegra haberte ayudado! üòä ¬øNecesitas algo m√°s?'
        : 'Lo siento, intentar√© mejorar üòì. ¬øEn qu√© fall√© exactamente?',
      user.userName,
    );
  }

  private async getWeeklyInsights(user: User): Promise<string> {
    const history = await this.historyService.getHistory(user.phoneNumber);
    const lastWeek = history.filter(
      (entry) => entry.date >= new Date(Date.now() - 7 * 86400000),
    );

    if (lastWeek.length === 0) return '';

    const avg =
      lastWeek.reduce((sum, entry) => sum + entry.emotionalScale, 0) /
      lastWeek.length;
    const trend =
      avg > (user.weeklyAverage || 0) ? 'mejorando üìà' : 'bajando üìâ';

    await this.userService.updateUser({ ...user, weeklyAverage: avg });

    return `\n*Insight semanal üìà:* Tu promedio fue ${avg.toFixed(1)}/10 (${trend}).`;
  }

  private async updatePositiveEmotionStreak(
    user: User,
    escala: number,
  ): Promise<void> {
    const today = new Date();
    const lastDate = user.lastPositiveEmotionDate;

    if (escala >= 7) {
      if (lastDate) {
        const diffInDays = Math.floor(
          (today.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24),
        );
        user.positiveEmotionStreak =
          diffInDays === 1 ? user.positiveEmotionStreak + 1 : 1;
      } else {
        user.positiveEmotionStreak = 1;
      }
      user.lastPositiveEmotionDate = today;
    } else {
      user.positiveEmotionStreak = 0;
    }

    await this.userService.updateUser(user);
  }

  private getErrorResponse(): ChatbotResponse {
    return this.buildResponse(
      'Hubo un error al procesar tu mensaje. Por favor, int√©ntalo de nuevo.',
      undefined,
    );
  }
}
